;;-*-Lisp-*-
(in-package goal)

;; name: mod-spectator-mode.gc
;; name in dgo: mod-spectator-mode
;; dgos: TODO

(define *spectator-handler* (new 'global 'spectator-handler))

(defun select-new-spectator ((search-forward symbol))
  (let ((selected-target (get-target (-> *spectator-handler* spectator_idx)))
        (original-index (-> *spectator-handler* spectator_idx)))
    (if (not selected-target) (set! selected-target *target*))
    (dotimes (tgt-idx MAX_MULTIPLAYER_COUNT)
      (let ((target (get-target tgt-idx)))
        (when (and target (not (is-inactive? tgt-idx)))
          (if (= selected-target *target*) (set! selected-target target))
          (cond
            ((= search-forward #t)
             (when (> tgt-idx original-index)
               (set! (-> *spectator-handler* spectator_idx) tgt-idx)
               (return target)))
            (else
             (cond
               ((and (< tgt-idx original-index) (!= target *target*))
                (set! (-> *spectator-handler* spectator_idx) tgt-idx)
                (set! selected-target target))
               ((!= (-> *spectator-handler* spectator_idx) original-index) (return selected-target))))))))
    (cond
      ;;pick first target found if move forwards and none found
      ((and (= search-forward #t) (= (-> *spectator-handler* spectator_idx) original-index))
       (dotimes (tgt-idx MAX_MULTIPLAYER_COUNT)
         (let ((target (get-target tgt-idx)))
           (when (and target (!= target *target*) (not (is-inactive? tgt-idx)))
             (set! selected-target target)
             (set! (-> *spectator-handler* spectator_idx) tgt-idx)
             (return selected-target)))))
      ;;pick last target found if move backwards and none found
      ((and (= search-forward #f) (= (-> *spectator-handler* spectator_idx) original-index))
       (dotimes (tgt-idx MAX_MULTIPLAYER_COUNT)
         (let ((target (get-target tgt-idx)))
           (when (and target (!= target *target*) (not (is-inactive? tgt-idx)))
             (set! selected-target target)
             (set! (-> *spectator-handler* spectator_idx) tgt-idx))))
       (return selected-target)))
    selected-target))

(defun change-spectator ((search-forward symbol) (force-refocus symbol))
  (let ((spec-target (select-new-spectator search-forward)))
    (when (and spec-target (!= spec-target *target*))
      (send-event *camera* 'change-target spec-target)
      (when force-refocus
        (send-event *camera* 'change-state cam-free-floating 0)
        (camera-change-to (the-as string 'base) 300 #f)
        (set! (-> *spectator-handler* is_refocusing?) #t)))
    (!= spec-target *target*)))

(defun force-stance-all ()
  (dotimes (tgt-idx MAX_MULTIPLAYER_COUNT)
    (let ((tgt (get-target tgt-idx)))
      (when (and tgt (!= tgt *target*) (target-on-foot? tgt))
        (go-process tgt target-stance)))))

(defun spectator-mode-main ()
  ;;ensure grabbed
  (if (not (is-grabbed?)) (process-grab? *target*))
  ;; is for some reason applied at the start of the run after teleport to hut
  (if (has-camera-type? 'cam-circular) (camera-change-to (the-as string 'base) 10 #f))
  (if (has-camera-type? 'cam-circular) (camera-change-to (the-as string 'base) 10 #f))
  ;; find initial target logic
  (if (and (not (-> *spectator-handler* has_found_initial_target?))
           (game-has-other-targets?)
           (or (has-camera-type? 'cam-free-floating) (change-spectator #t #f)))
    (set! (-> *spectator-handler* has_found_initial_target?) #t))
  (if (not (-> *camera* drawable-target)) (set! (-> *spectator-handler* has_found_initial_target?) #f))
  (when (>= (-> *display* base-frame-counter) (-> *spectator-handler* next_logic_check))
    (set! (-> *spectator-handler* next_logic_check) (+ (current-time) (seconds 0.5)))
    ;;check refocus need
    (when (has-camera-type? 'cam-string)
      (let ((spec-target (get-spectator-target)))
        (when spec-target
          (if (-> *spectator-handler* is_refocusing?)
            (when (is-camera-within-target-dist? spec-target (-> *spectator-handler* refocus_dist))
              (set! (-> *spectator-handler* is_refocusing?) #f))
            (when (not (is-camera-within-target-dist? spec-target (-> *spectator-handler* refocus_dist)))
              (set! (-> *spectator-handler* is_refocusing?) #t)
              (send-event *camera* 'change-state cam-free-floating 0)
              (camera-change-to (the-as string 'base) 400 #f))))))
    ;;ensure level is loaded
    (cond
      ((-> *spectator-handler* in_level_check_wait?)
       (when (>= (-> *display* base-frame-counter) (-> *spectator-handler* next_level_check))
         (set! (-> *spectator-handler* in_level_check_wait?) #f)
         (let ((level-name (-> *multiplayer-info* players (-> *spectator-handler* spectator_idx) current_level)))
           (when (not (is-level-alive? level-name))
             (set! (-> *spectator-handler* check_vis_nick?) #t)
             (set! (-> *spectator-handler* next_vis_nick_check) (+ (current-time) (seconds 4.0)))
             (cond
               ((-> *spectator-handler* full_new_level?)
                (format #t "full loading level ~s in slot ~d ~%" level-name 1)
                (set! (-> *setting-control* default border-mode) #t)
                (load-state-want-levels (-> *multiplayer-info* players (-> *multiplayer-info* player_num) current_level) level-name)
                (load-state-want-display-level level-name 'display)
                (set! (-> *spectator-handler* last_level_slot_used) 1)
                (set! (-> *spectator-handler* full_new_level?) #f))
               (else
                (let ((level-slot (get-preferable-level-slot)))
                  (set! (-> *spectator-handler* last_level_slot_used) level-slot)
                  (format #t "force loading level ~s in slot ~d ~%" level-name level-slot)
                  (if (= level-slot 0)
                    (load-state-want-levels level-name (-> *load-state* want 1 name))
                    (load-state-want-levels (-> *load-state* want 0 name) level-name))
                  (load-state-want-display-level level-name 'display))))))))
      ((not (is-target-current-level-alive? (-> *spectator-handler* spectator_idx)))
       (let ((level-name (-> *multiplayer-info* players (-> *spectator-handler* spectator_idx) current_level)))
         (when (is-valid-level? level-name)
           (set! (-> *spectator-handler* in_level_check_wait?) #t)
           (cond
             ((-> *spectator-handler* is_refocusing?)
              (format #t "full level load ~%")
              (set! (-> *setting-control* default border-mode) #f)
              (set! (-> *spectator-handler* render_animations?) #f)
              (force-stance-all)
              (set! (-> *spectator-handler* full_new_level?) #t)
              (cond
                ((not (is-level-alive? (-> *multiplayer-info* players (-> *multiplayer-info* player_num) current_level)))
                 (load-state-want-levels (-> *multiplayer-info* players (-> *multiplayer-info* player_num) current_level)
                                         (-> *load-state* want 1 name))
                 (load-state-want-display-level (-> *multiplayer-info* players (-> *multiplayer-info* player_num) current_level) 'display)
                 (set! (-> *spectator-handler* next_level_check) (+ (current-time) (seconds 3.0))))
                (else (set! (-> *spectator-handler* next_level_check) (current-time)))))
             (else
              (format #t "force level load ~%")
              (set! (-> *spectator-handler* full_new_level?) #f)
              (set! (-> *spectator-handler* next_level_check) (+ (current-time) (seconds 3.0))))))))))
  ;;post vis check
  (when (and (-> *spectator-handler* check_vis_nick?)
             (is-target-current-level-alive? (-> *spectator-handler* spectator_idx))
             (not (-> *spectator-handler* is_refocusing?))
             (>= (-> *display* base-frame-counter) (-> *spectator-handler* next_vis_nick_check)))
    (set! (-> *spectator-handler* check_vis_nick?) #f)
    (set! (-> *spectator-handler* render_animations?) #t)
    (if (!= (-> *load-state* vis-nick) (-> *multiplayer-info* players (-> *spectator-handler* spectator_idx) current_level))
      (load-state-want-vis (-> *multiplayer-info* players (-> *spectator-handler* spectator_idx) current_level))))
  ;;spectator toggles
  (when (not (and (cpad-hold? 0 l2) (cpad-hold? 0 r2)))
    (cond
      ((cpad-pressed? 0 r3)
       (if (has-camera-type? 'cam-free-floating)
         (camera-change-to (the-as string 'base) 400 #f)
         (send-event *camera* 'change-state cam-free-floating 300)))
      ((cpad-pressed? 0 up)
       (if (has-camera-type? 'cam-lookat)
         (camera-change-to (the-as string 'base) 400 #f)
         (send-event *camera* 'change-state cam-lookat 200)))
      ((cpad-pressed? 0 down)
       (send-event *camera* 'change-state cam-free-floating 0)
       (camera-change-to (the-as string 'base) 400 #f))
      ((cpad-pressed? 0 right) (change-spectator #t #t))
      ((cpad-pressed? 0 left) (change-spectator #f #t)))))
